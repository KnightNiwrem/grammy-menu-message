import type {
  CopyTextButton,
  InlineKeyboardButton,
  LoginUrl,
  SwitchInlineQueryChosenChat,
  WebAppInfo,
} from "grammy/types";
import type { MiddlewareFn } from "grammy";
import { Menu, type MenuButton } from "./menu.ts";

type Operation =
  | { type: "button"; data: InlineKeyboardButton }
  | { type: "cbButton"; label: string; middleware: MiddlewareFn }
  | { type: "row" };

/**
 * MenuTemplate defines the structure of a menu using a builder pattern.
 * It provides methods to add buttons and organize them into rows.
 * Objects are created fresh on each render() call.
 */
export class MenuTemplate {
  private operations: Operation[] = [];

  /**
   * Adds a callback button to the current row.
   * @param label The text displayed on the button
   * @param callbackData The callback data sent when the button is pressed
   * @returns this for method chaining
   */
  rawCb(label: string, callbackData: string): this {
    this.operations.push({
      type: "button",
      data: { text: label, callback_data: callbackData },
    });
    return this;
  }

  /**
   * Adds a callback button controlled by middleware to the current row.
   * The callback_data is generated by prepending the renderedMenuId to the button's position.
   * @param label The text displayed on the button
   * @param middleware The middleware function to handle the callback
   * @returns this for method chaining
   */
  cb(label: string, middleware: MiddlewareFn): this {
    this.operations.push({
      type: "cbButton",
      label,
      middleware,
    });
    return this;
  }

  /**
   * Adds a URL button to the current row.
   * @param text The text displayed on the button
   * @param url HTTP or tg:// URL to be opened when the button is pressed
   * @returns this for method chaining
   */
  url(text: string, url: string): this {
    this.operations.push({
      type: "button",
      data: { text, url },
    });
    return this;
  }

  /**
   * Adds a web app button to the current row.
   * @param text The text displayed on the button
   * @param url An HTTPS URL of a Web App to be opened with additional data
   * @returns this for method chaining
   */
  webApp(text: string, url: string | WebAppInfo): this {
    this.operations.push({
      type: "button",
      data: {
        text,
        web_app: typeof url === "string" ? { url } : url,
      },
    });
    return this;
  }

  /**
   * Adds a login button to the current row.
   * @param text The text displayed on the button
   * @param loginUrl The login URL as string or LoginUrl object
   * @returns this for method chaining
   */
  login(text: string, loginUrl: string | LoginUrl): this {
    this.operations.push({
      type: "button",
      data: {
        text,
        login_url: typeof loginUrl === "string" ? { url: loginUrl } : loginUrl,
      },
    });
    return this;
  }

  /**
   * Adds an inline query button to the current row.
   * @param text The text displayed on the button
   * @param query The optional inline query string to prefill
   * @returns this for method chaining
   */
  switchInline(text: string, query = ""): this {
    this.operations.push({
      type: "button",
      data: { text, switch_inline_query: query },
    });
    return this;
  }

  /**
   * Adds an inline query button for the current chat to the current row.
   * @param text The text displayed on the button
   * @param query The optional inline query string to prefill
   * @returns this for method chaining
   */
  switchInlineCurrent(text: string, query = ""): this {
    this.operations.push({
      type: "button",
      data: { text, switch_inline_query_current_chat: query },
    });
    return this;
  }

  /**
   * Adds an inline query button with chosen chat filter to the current row.
   * @param text The text displayed on the button
   * @param query The query object describing which chats can be picked
   * @returns this for method chaining
   */
  switchInlineChosen(
    text: string,
    query: SwitchInlineQueryChosenChat = {},
  ): this {
    this.operations.push({
      type: "button",
      data: { text, switch_inline_query_chosen_chat: query },
    });
    return this;
  }

  /**
   * Adds a copy text button to the current row.
   * @param text The text displayed on the button
   * @param copyText The text to be copied to the clipboard
   * @returns this for method chaining
   */
  copyText(text: string, copyText: string | CopyTextButton): this {
    this.operations.push({
      type: "button",
      data: {
        text,
        copy_text: typeof copyText === "string" ? { text: copyText } : copyText,
      },
    });
    return this;
  }

  /**
   * Adds a game button to the current row.
   * This type of button must always be the first button in the first row.
   * @param text The text displayed on the button
   * @returns this for method chaining
   */
  game(text: string): this {
    this.operations.push({
      type: "button",
      data: { text, callback_game: {} },
    });
    return this;
  }

  /**
   * Adds a payment button to the current row.
   * This type of button must always be the first button in the first row and
   * can only be used in invoice messages.
   * @param text The text displayed on the button
   * @returns this for method chaining
   */
  pay(text: string): this {
    this.operations.push({
      type: "button",
      data: { text, pay: true },
    });
    return this;
  }

  /**
   * Finalizes the current row and starts a new one.
   * @returns this for method chaining
   */
  row(): this {
    this.operations.push({ type: "row" });
    return this;
  }

  /**
   * Renders the template into a Menu with a fresh inline keyboard instance.
   * @param renderedMenuId Unique menu ID used to generate callback_data for cb buttons
   * @returns A Menu instance with newly constructed buttons
   */
  render(renderedMenuId: string): Menu {
    const rows: InlineKeyboardButton[][] = [];
    const menuRows: MenuButton[][] = [];
    let currentRow: InlineKeyboardButton[] = [];
    let currentMenuRow: MenuButton[] = [];

    for (const op of this.operations) {
      if (op.type === "button") {
        currentRow.push(op.data);
        currentMenuRow.push(op.data as MenuButton);
      } else if (op.type === "cbButton") {
        const rowNum = rows.length;
        const colNum = currentRow.length;
        const callbackData = `${renderedMenuId}:${rowNum}:${colNum}`;
        const button: InlineKeyboardButton = {
          text: op.label,
          callback_data: callbackData,
        };
        currentRow.push(button);
        const menuButton: MenuButton = {
          ...button,
          middleware: op.middleware,
        };
        currentMenuRow.push(menuButton);
      } else if (op.type === "row") {
        if (currentRow.length > 0) {
          rows.push(currentRow);
          menuRows.push(currentMenuRow);
          currentRow = [];
          currentMenuRow = [];
        }
      }
    }

    if (currentRow.length > 0) {
      rows.push(currentRow);
      menuRows.push(currentMenuRow);
    }

    return new Menu(renderedMenuId, menuRows, rows);
  }
}
